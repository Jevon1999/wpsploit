"""
GitLab ExploitDB Integration Class
Fungsi: Integrasi dengan ExploitDB repository di GitLab untuk download dan parse eksploit.
Isi: Class ExploitDBGitlab dengan method untuk clone repo, parse files, map CVE, cache.
"""

import os
import json
import subprocess
import re
from pathlib import Path
from utils import Logger

class ExploitDBGitlab:
    def __init__(self, logger, repo_url="https://gitlab.com/exploit-database/exploitdb.git", cache_dir="cache/exploitdb"):
        # Fungsi: Inisialisasi
        # Isi: Setup repo URL, cache dir, logger
        self.logger = logger
        self.repo_url = repo_url
        self.cache_dir = Path(cache_dir)
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self.exploits_db = self.cache_dir / "exploits.json"
        self.cve_map = {}  # Cache CVE to exploits
    
    def update_repo(self):
        # Fungsi: Clone atau update repo GitLab
        # Isi: Git clone/pull ke cache_dir dengan retry logic
        import time
        
        repo_path = self.cache_dir / "repo"
        max_retries = 3
        retry_delay = 2
        
        for attempt in range(max_retries):
            try:
                if not repo_path.exists():
                    self.logger.info(f"Cloning ExploitDB repo (attempt {attempt + 1}/{max_retries})...")
                    subprocess.run(
                        ["git", "clone", "--depth", "1", self.repo_url, str(repo_path)],
                        check=True,
                        capture_output=True,
                        text=True,
                        timeout=300
                    )
                    self.logger.info("Repository cloned successfully")
                else:
                    self.logger.info(f"Updating ExploitDB repo (attempt {attempt + 1}/{max_retries})...")
                    result = subprocess.run(
                        ["git", "-C", str(repo_path), "pull"],
                        check=True,
                        capture_output=True,
                        text=True,
                        timeout=120
                    )
                    if "Already up to date" in result.stdout:
                        self.logger.info("Repository already up to date")
                    else:
                        self.logger.info("Repository updated successfully")
                return repo_path
            except subprocess.TimeoutExpired:
                self.logger.error(f"Git operation timed out on attempt {attempt + 1}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    continue
                else:
                    raise Exception("Git operation timed out after all retries")
            except subprocess.CalledProcessError as e:
                self.logger.error(f"Git error on attempt {attempt + 1}: {e.stderr}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    continue
                else:
                    raise Exception(f"Git operation failed after all retries: {e.stderr}")
            except Exception as e:
                self.logger.error(f"Unexpected error on attempt {attempt + 1}: {e}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    continue
                else:
                    raise
        
        raise Exception("Failed to update repo after all retries")
    
    def parse_exploits(self, repo_path):
        # Fungsi: Parse files eksploit
        # Isi: Baca files.csv, parse untuk CVE dan platform WordPress
        files_csv = repo_path / "files_exploits.csv"
        exploits = []
        
        if not files_csv.exists():
            self.logger.warning(f"files_exploits.csv tidak ditemukan di {repo_path}")
            # Try alternatif: scan exploits directory
            exploits_dir = repo_path / "exploits"
            if exploits_dir.exists():
                self.logger.info("Scanning exploits directory...")
                exploits = self._scan_exploits_directory(exploits_dir)
        else:
            try:
                with open(files_csv, 'r', encoding='utf-8', errors='ignore') as f:
                    next(f, None)  # Skip header
                    for line_num, line in enumerate(f, start=2):
                        try:
                            # Parse CSV dengan handling quotes
                            parts = self._parse_csv_line(line)
                            if len(parts) >= 3:
                                exploit_id = parts[0].strip()
                                file_path = parts[1].strip()
                                description = parts[2].strip() if len(parts) > 2 else ""
                                platform = parts[5].strip() if len(parts) > 5 else ""
                                
                                # Extract CVE dari description atau tags
                                cves = self._extract_cves(description + " " + (parts[3] if len(parts) > 3 else ""))
                                
                                # Filter WordPress/webapps
                                if self._is_wordpress_related(description + " " + platform + " " + file_path):
                                    exploits.append({
                                        'id': exploit_id,
                                        'file': file_path,
                                        'title': description,
                                        'cves': cves,
                                        'platform': platform,
                                        'path': str(repo_path / file_path)
                                    })
                        except Exception as e:
                            self.logger.warning(f"Error parsing line {line_num}: {e}")
                            continue
            except Exception as e:
                self.logger.error(f"Error reading CSV: {e}")
        
        self.logger.info(f"Parsed {len(exploits)} WordPress-related exploits")
        # Cache to JSON
        with open(self.exploits_db, 'w') as f:
            json.dump(exploits, f, indent=2)
        
        # Build CVE map
        self._build_cve_map(exploits)
        return exploits
    
    def _parse_csv_line(self, line):
        """Parse CSV line dengan handling quotes"""
        parts = []
        current = ""
        in_quotes = False
        for char in line:
            if char == '"':
                in_quotes = not in_quotes
            elif char == ',' and not in_quotes:
                parts.append(current)
                current = ""
            else:
                current += char
        parts.append(current)
        return parts
    
    def _extract_cves(self, text):
        """Extract semua CVE dari text"""
        cve_pattern = re.compile(r'CVE-\d{4}-\d+', re.IGNORECASE)
        cves = cve_pattern.findall(text.upper())
        return list(set(cves))  # Unique
    
    def _is_wordpress_related(self, text):
        """Check apakah exploit terkait WordPress"""
        text_lower = text.lower()
        keywords = ['wordpress', 'wp-', 'wp_', '/wp/', 'woocommerce', 'wpml']
        return any(kw in text_lower for kw in keywords)
    
    def _scan_exploits_directory(self, exploits_dir):
        """Scan directory exploits sebagai fallback"""
        exploits = []
        for exploit_file in exploits_dir.rglob('*.txt'):
            try:
                content = exploit_file.read_text(encoding='utf-8', errors='ignore')
                if self._is_wordpress_related(content[:1000]):
                    cves = self._extract_cves(content[:1000])
                    exploits.append({
                        'id': exploit_file.stem,
                        'file': str(exploit_file.relative_to(exploits_dir.parent)),
                        'title': exploit_file.name,
                        'cves': cves,
                        'platform': 'unknown',
                        'path': str(exploit_file)
                    })
            except:
                continue
        return exploits
    
    def _build_cve_map(self, exploits):
        """Build mapping CVE -> exploits untuk quick lookup"""
        self.cve_map = {}
        for exploit in exploits:
            for cve in exploit.get('cves', []):
                if cve not in self.cve_map:
                    self.cve_map[cve] = []
                self.cve_map[cve].append(exploit)
    
    def load_cached_exploits(self):
        # Fungsi: Load exploits dari cache
        # Isi: Baca JSON cache
        if self.exploits_db.exists():
            with open(self.exploits_db, 'r') as f:
                return json.load(f)
        return []
    
    def get_exploits_by_cve(self, cve):
        # Fungsi: Cari exploits berdasarkan CVE
        # Isi: Filter dari cache menggunakan CVE map
        cve_upper = cve.upper()
        
        # Try dari memory map dulu (faster)
        if cve_upper in self.cve_map:
            return self.cve_map[cve_upper]
        
        # Fallback ke cache file
        exploits = self.load_cached_exploits()
        matched = []
        for e in exploits:
            cves = e.get('cves', [])
            if isinstance(cves, str):
                cves = [cves]
            if cve_upper in [c.upper() for c in cves]:
                matched.append(e)
        return matched
    
    def download_exploit(self, exploit):
        # Fungsi: Download kode eksploit
        # Isi: Baca file dari repo path
        try:
            # Try direct path first
            if 'path' in exploit and Path(exploit['path']).exists():
                with open(exploit['path'], 'r', encoding='utf-8', errors='ignore') as f:
                    code = f.read()
                    self.logger.info(f"Loaded exploit {exploit['id']} ({len(code)} bytes)")
                    return code
            
            # Fallback ke relative path
            repo_path = self.cache_dir / "repo"
            file_path = repo_path / exploit['file']
            if file_path.exists():
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    code = f.read()
                    self.logger.info(f"Loaded exploit {exploit['id']} ({len(code)} bytes)")
                    return code
            else:
                self.logger.warning(f"Exploit file not found: {file_path}")
        except Exception as e:
            self.logger.error(f"Error downloading exploit {exploit['id']}: {e}")
        return None